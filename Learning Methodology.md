# Skill Learning Methods / How I learn / Notes on skill learning

Procedural note in putting together this document: don't worry to much about the order or organization. That can come latter. Just collect strategies and heuristics, as independent units

## Foundations 

### Core concepts:

* Active Learning 
* 1-on-1 instruction
* Spaced repetition
* Targeting the domain of proximal competence and right-sizing chunks.
* Chunking and consolidation
* Goal-relevance

### Principles of deliberate practice


- Focus intently 
- Find the limits of your ability
- Fix your errors
- Feedback

### Philosophy

Declarative knowledge is degenerate procedural knowledge. 

## Heuristics and techniques

### Focus

My juggling times are noticeably weaker when I'm distracted by other things on my mind, such as an essay that I'm writing in my head, or additions that I want to make to this document.

### Deliberate practice is about 50% sitting down with paper / thinky work / theoretical work


* Describing your model of what's happening
* Describing your model of the learning process
* Delineating what's going wrong
* brainstorming interventions to try

### First do it right, then do it smooth, then do it quiet, then do it fast

Epistemic status:

### What gets measured gets managed

Epistemic status:

Maintaining an a focused intention is easier said than done. All to often I'll set out to practice some specific sub-skill or to focus on some specific aspect of a practice, only to implicitly be motivated to focus on something else, or to slide into mindless repetition.

(Link to my thing about inner intention and outer intention?)

The simplest way that I know of to address this is to simply track and record your performance at the specific metric at which I want to improve. Somehow, doing this incentives the part of me that directs my inner intention.

Importantly, *just* setting up tracking is usually not sufficient. I still need to intentionally make a point to on the activity and have the intention of succeeding at the activity. I still have to try.

Examples:

* Touch Typing: I was "focusing on accuracy" for (weeks? months?) with my touch typing, but inevitably I would feel some pressure / temptation to go fast. This is unsurprising, since I was recording my speeds for each trial. Even if I was wanting to slow down and focus on accuracy, I was hedonically rewarded for fast trial times. Only after I started recording my accuracy scores in the spreadsheet, did that become my actual in-the-moment target, and did my accuracy improve. (link)
* Juggling: I was plateauing with juggling for more than a month. I did a session in which I logged how long, in minutes, I was able to hold the juggling pattern for. In that session, I broke 60 seconds (for the first time) multiple times, and my best time was 50% than my record-to-date. (link)

### Smaller, even smaller

Juggling: I could juggle at all, but the arcs that the balls were traveling were not smooth or consistent. I knew that I should back up to practicing tossing only one ball, one at a time, in a consistent arc, but I despaired of this actually working - it felt like I could do hundreds of repetitions without improving at all. 


That despair was a hint that I hadn't chunked out the exercise enough. I thought that I couldn't get any more basic than that at controlling the trajectory of the ball. But actually I needed have backed up even further, to just throwing the ball straight up in the air, at a consistent height, and catching it, or to throwing it at a target on the ground. [2021-09-18 note: I still need to do this, actually]

### Finding Control Systems

Epistemic status:

Examples:

- **Touch typing** - In learning touch typing at speed, I learned to [notice when I was rushing](https://efficacyengineering.wordpress.com/2020/07/26/my-current-phenomenological-model-of-my-typing-skill/), and slow down to focus on precision, and to notice when things felt smooth, so that [I could push more oomph into it](`https://efficacyengineering.wordpress.com/2020/07/26/my-current-phenomenological-model-of-my-typing-skill/`). Combined, these created a kind of control system of keeping the "intensity" in line with my structure, without getting ahead of myself, or rushing. [note that that isn't exactly what the first link describes, though it does match my memory]
- **Juggling** - Noticing the balls deviating somewhat from that pattern, and focusing on making "adjustments" that to bring the pattern back in line. 

### Do ten times as much

See [this](https://betonit.substack.com/p/do-ten-times-as-much) post.

### Rapid alteration

Epistemic status:

If there are two patterns that you tend to get mixed up, practice with a training regime where you rapidly alternate between them, semi-randomly.

Go as slowly as you need to in order to notice, and concretely decide 

Examples:

* **Spelling** - If I tend to mess up which words are spelled with an "ie" and which words are spelled with an "ei", (ie "pieces" and "recieve"), I'll do a typing / spelling practice session, in which only or mostly includes words with those two patterns, so that I have to pay attention to which is needed for each word, and build the more neuanced skill of typing the right pattern in the right context, instead of building the habit of always typing ie, and then overiding that habit with always typing ei, and generally getting muddled. 

### Identify earlier and more subtle gradients / feedback mechanisms; make smaller earlier corrections

Epistemic status:


- Juggling: I could tell when I missed a catch or dropped a ball, but by that point it was already too late to do a correction, and the pattern would collapse. But I noticed that I would catch the ball with different parts of my hand, sometimes between my fingers, sometimes on the ridge between my thumb and forefinger, sometimes on my palm. When I caught the ball with my fingers, I would typically loose control of the pattern a few steps latter. But, this was early enough that I could do the correction: making sure to catch with my palm on the next iteration. 


###Start with a stripped down scenario / start with the endgame / work backwards

Stolen from Josh Waitzkin (Chapter and 11 of the Art of Learning)

Examples:

* When learning Jujitsu, start by practicing maintaining a single pin, and getting out of that pin, and learning the principles that govern that situation, and gradually work backwards to the throws that, when executed correctly, put you in that position.

### Do a smaller thing, with greater ease-ness

If the exercise that I've selected for myself feels frustrating, then it isn't the right exercise yet.


See also: chunking to size

###What you can't control, just predict



Juggling - If I'm trying to throw a ball up in the air and hit a target (or my foot, since then I have immediate feedback without needing to look), and I'm finding that this is really hard, I can start by throwing the ball at the target, and trying to predict, after it leaves my hand, but before it lands, if the ball will hit the target. Oftentimes I will be able to feel that a throw was "good" or "off", which attunes me to that feedback mechanism. And sometimes, I'll be *surprised*, I expect a throw to land, and it doesn't, or vis versa, which allows me to refine my feeling of what "good" feels like.

### Rushing doesn't pay



### The ADEPT method

From: https://betterexplained.com/articles/adept-method/

1. Analogy
2. Diagram
3. Example
3. Plain english


###If there's progress, I should be able to feel it.
I think that it should be a flag when I can't seem improvement __over the course of a session__. That that suggests that I've bitten off to large a chunk, and I need to back up and do a smaller or simpler or less complex exercise.

###Iterative paraphrasing

Learning that involves carving out an ontology is done by iteratively paraphrasing. Just keep working over my current understanding in my mind, correcting my mistakes, until I can express it cleanly and correctly.

This needs to be done with feedback. Which means having a tutor.



### Chunking to size

If something feels to hard or ownerous, such that I'm bouncing off of it, that means that I'm trying to take too big a chunk at once, and I need to break it down into simpler components. 

In general, the proximal next step should always feel tractable. If it isn't, I'm trying to do too big of a chunk at once.





* Algebra - I'm trying to deeply understand how and why the quadratic formula works. This depends on completing the square. So I don't feel solid about what "completing the square" is or why it works, I'll back up, leaving the quadratic formula for now, and make my new goal just understand completing the square deeply. (Concretely, I'll make a math chunk roam page for "completing the square" and put it in spaced repetition.) After solidifying my understanding of completing the square, by playing with the idea and probably doing some cycles of khan academy exercises in spaced repetition, do I go back to the quadratic formula.


As I learn math, I'm traversing up and down a tree of simpler and more complicated components: I start with something that I want to learn, and then as I feel overwhelmed, I pull out simpler chunks that don't feel solid to me, and focus on those. I do this recursively, until I get down to some layer where each component piece is simple enough and I understand it well enough, that I can combine them into something new that fits together in a gearsy way, that I actually have understanding of why this has to be the case, instead of a flailing feeling of making guesses or memorizing arbitrary symbol strings. Then I build back up 

### Investing in Loss, and being willing to fail

### Your implements matter

Switching to a better keyboard made a huge difference for my ability to type

Which kind of balls I use make a huge difference for my juggling ability.

### Use a more sensitive instrument

Epistemic status: 

Find a version of the task or exercise that accentuates or amplifies your errors. This gives you stronger feedback on small errors and forces you to decrease your margin of error.

Examples:

- Juggling - Use lighter balls, which are harder to control, because they will deviate more from their trajectories from minute discrepancies in their throws.

### Find proprioceptive one-ness

Epistemic status:

### Stair-stepping
Epistemic status:

Alternate between a harder version and an easier version of the same exercise

Examples:

- Juggling - Alternate between juggling with easier, heavier balls, and harder, lighter balls.

### If I'm not making visible / measurable progress for three consecutive training sessions, mix up the training regime.

Most likely, slow down or find an even smaller chunk

### Do it again

In many domains understanding and learning material is at least a two step process: first struggling to find a solution that works, and then compressing and consolidating that solution into something that can actually fit in my mind and rehearsing the patern. 

In domains that involve problem solving, I'll solve a puzzle twice; after I struggle through finding a solution at all, I'll imeadiately do it again to consolidate the concepts and rehease the mental moves.


Examples: 

**Math**

After I've just finished struggling through a proof, my brain is tried and I'm probably sick of what I'm thinking about. And I feel like I've finally gotten it, and can be done for now.

But this is wrong. To get the majority (70%?) of the value of doing the proof in the first place, I need to consolidate my learning. I have a bunch of churned up conceptual pieces, formulated in an ad hoc sort of way: the connections between steps in the proof are tenuous and strained, barely fitting into my working memory. I need to compress all that into clean, compact representations that feel natural and intuitive, to really understand the proof in a way that will stick, to be able to chunk, if not the whole proof, then the components of the proof.

So the thing to do, even though it's far from the thing to do is to do the proof again, immediately, from the top. I have the outline and the context loaded up in short term memory, so it is much easier to do, and this allows me to consolidate the content: to streamline the reasoning and remove extraneous pieces (that are not clearly extraneous on the first pass, because I'm still running a search process). 

**Programming**

**Snakebird**

### Response to Frustration

See here: https://roamresearch.com/#/app/eli/page/SkeXTJk71

### Respond to Boredom



### Intense focus without tension




The point of reading is *to have new thoughts*.

### Rereading is overpowered

An idea from Winifred (h/t Rafe):

* Read the texbook on day 1
* Put the theorems into Anki on day 2
* Read the textbook in depth on day 3



### Paraphrasing / summarizing

- To my self
- To a partner
- To a tutor

### Visual/ Kinesthetic Metaphors







- "Why does this matter?"
- "How could I practice this?"
- "How would I use this?"
- "What's an example of this in my own life?"



### Generalizing 

### Layering



## Divided by steps

### Learning program design

#### Write out your first pass training plan





#### Inverting

From the First 20 Hours

When deconstructing a skill, teasing out all the necessary sub-skills, list all the way that things could go wrong. What if everything went wrong with what Iâ€™m trying to learn? What are all the ways I could fail? what would that look like?

Each failure mode is a pointer to a necessary sub skill

Quote the book



#### DiSSS

From Tim Ferris's podcast on meta learning (#191)

**Deconsturction**

- "What are the minium learnable units, the lego blocks, I should start with?"

**Selection**

- "Which 20% of the blocks should I focus on for 80% or more of the outcomes I want?"

**Sequencing**

- "In what order should I learn the blocks?"

**Stakes**

- "How do I set up stakes and real consequences to guaranty that I follow the program?"

#### CaFE

From Tim Ferris's podcast on meta learning (#191)

**Compression**

- "Can I encapsulate the most important 20% into an easily graspable 1-pager?"

**Frequency**

- "How frequently should I practice? Can I cram? What should my schedule look like? What growing pains can I predict? What is the minum effective dose per volume?

**Encoding**

- "How do I anchor the new material to things I already know for rapid recall?"
- Acronyms





## Diagnosis

- Sometimes it feels like it's "not working" -> find a smaller chunk.
- 	like juggning


- Sometimes it feels like like it's going through a sieve, like only a tiny trickle of info is getting in -> I should hire a tutor.
- 	like struggling to parse the einops documentation





-----------------

## How I learn - specific projects and processes 

### How I learn programming

#### Starting 

All of my programming learning is project-based: Instead of doing tutorials etc, I just dive right into trying to build some tool or script that would be concretely useful for me personally. (Whether or not it would be useful to someone else is not a question that I consider at all.)

I keep a running list ideas for applications to build, processes to automate, and new features for software that I've already built, and I pick projects from that list. I'll bias towards things that are fast to build, things that I think I might use every day, and things that are just beyond my current knowledge of how to start.

So far this tends to be... 

* scripts and processes to automate or streamline workflows that I already do manually, or
* Tools that somehow make it easier or faster for me to learn or practice something.

Then I'll find a tutor to help me. If I'm hacking on or extending an existing peice of software, I might find the community hubs for that software and make a post saying that I'm a medium-novice programmer, I'm interested in building some [whatever] extentions, and ask if anyone would be interested in tutoring me, a combination of teaching me how to do it and pair programming with me, in exchange for money. For instance, when there were some simple roam extensions that I wanted to build, I asked on the #roam-hacking channel of the roam slack, and found a person to work with that way.

For this, I'm usually not looking for someone who's done a lot of tutoring, necessarily, just a moderately skilled software engineer who's familar with the software we're working with. 

For projects that are starting from scratch, I'll start by writing a one page spec of what I'm wanting, and ask my software engineering friends what tech stack they think I should use. Then I'll search for tutors on Wyzant.com who are familiar with those technologies. 

With Wyzant tutors, I'll typically try a few over the course of a week or two to filter for one that's really good: one of the main features that I'm looking for is if they're tracking what my level of understanding is (Are their answers to my questions meeting me where I'm currently at, or are they skipping over inferential differences?) and how easy is it to get them to give me the space to think through a problem myself, instead just telling me the answre.

#### Each session

I'll typically book 4 hour sessions with a tutor, with a planned 20 minute break in the middle.

I always do programming sessions with a dual monitor setup: VS code and the application itself (in a browser usually), in the larger external monitor, and a notes page on my laptop monitor.

Depending on how familiar I am with the tech stack that we're working with, the tutor might be almost entirely steering. But I do all of the typing, and I ask questions about what various things do and why as we go. Anything that feels "big" in my mind, I paraphrase back, to consolidate my understanding. 

I'll take notes on key concepts and on the syntax of the language that I'm using. I also air on the side of commenting too much, leaving pretty detailed notes about what each block of code does for future-Eli.

For any given bug, I'll generate a sketch of how I would try and solve it if I were working myself, first, and then the tutor might share their solution. Usually my solution *would* work, but their solution has better design principles. And usually, hearing their solution I'm able to correctly guess / extrapolate what those design principles are. I'll paraphrase, and then take notes on those as well.

Within a day or two (a few days at the most), I'll review all my notes from the session, during batched notes review, and make anki cards for all of the new syntax, so that the fiddly procedural details are "at hand" for me the next time I need to use them.

After we've completed a large section of the code, I might spend a whole session or more walking through the program-flow: where does it start, and which functions trigger which functions. In the process I'll streamline the code or rename variables to be easier to follow, and leave comments describing what the code is doing, but mainly I'm consolidating and compressing my understanding of the whole interlocking machine of that code section.

I might also spend whole sessions refactoring my code, if the way the project developed 

I'll hack away on a project like this, with the tutor's help, until I get my feet under me.

#### Reading documentation

One specific sub-skill to develop to being able to program independently is reading documentation. 

I don't have much of a handle on how to do this yet, but I suppose that I should use the same basic pattern as above.

For any particular piece of functionality of a given library, I start trying to look it up myself. Maybe I should read for a time-boxed 5 minutes, narrating my thought process out loud as I go, and then at the end of 5 minutes have the tutor offer feedback about my search process: were there hints about whether a given bit of documentation had the info I wanted, or not, that I missed?

### As I mature

Eventually, I'll get familiar enough with a given tech stack, I know the key steps for how to get started with a project and the basic alphabet of basic functions and syntax to compose.

When I reach this stage, I'll start starting projects on myself: sitting down and trying to build the tool that I want to use. 

However, I'll still have a low bar to booking a tutoring session, to ask for help if I get stuck. 

If I don't know how to build something, I'll ask ChatGPT (or similar), including asking followup questions. But if I don't feel like that's giving me a conceptual model or it isn't solving my problem, I'll book a session with a tutor to go over it.

And when I'm debugging, I typically don't spend more than an hour trying to root out the bug, before either asking a friends or hiring a tutor who has more familiarity with the specific tech stack that I'm using.

### How I learned arithmetic

### How I learn spelling


When I get tripped up on some specific letter combination, I'll come up with a mnemonic to 


###How I learn math


* If a card ever feels onerous or [ughy](https://www.lesswrong.com/posts/EFQ3F6kmt4WHXRqik/ugh-fields), that's a sign that it is two large, and I need to break it down into smaller, more manageable / trackable feeling chunks. (This is important, because otherwise, I'm apt to churn through all of the cards that I feel the affordance to make progress on, and then be left with a deck filled with cards that feel annoying and frustrating, and then I will develop an ugh field around doing a learning chunk review at all.)
* Or get tutoring


* Prioritize which material has good explainations.

* I made it low friction to schedule tutoring


* Short, high level summaries

### How I learn programming and software engineering

My approach is pretty goal oriented / project first. Instead of doing tutorials etc, I'll always dive right in to building some particular application that seems useful or appealing to me.

I keep a running list of programming projects and things to automate. So if I'm wanting to learn a particular skillset (say web development), I'll pick a project from that list. (I'll bias towards smaller, easier projects and build up from there.)

Then I'll just start building it. Often when I'm just starting out with a technology or a framework, I'll have close to no idea how to start. But instead of reading through documentation, I'll just book some sessions with a tutor: I'll tell them what I'm trying to do, and they tell me how to implement each step. I'll take notes in parellel while we're programing, noting noting important details about the technology, including the syntax for performing different operations. After each session, I'll compress those notes into anki cards.

Usually, a few sessions is enough to get me up and running and I can start tinkering with the application on my own. But I have a low bar for scheduling additional tutoring sessions, when I'm stuck. I'll show up with some code that isn't doing what I'm wanting, and ask what's going wrong. I'm looking to learn what conceptual error I was making: what my abstraction of my code was vs what my code was actually doing, and will rehearse / reify the new, correct abstractions. Again, I'm taking notes that I'll convert into anki cards.

After I have an application working, I'll sit down with a friend to look over it and see if there are ways to clean up my code to make it more readable or more efficient. (I'm sitting down with a friend, instead of a tutor, because for this task I want to be learning from really excelent programers, with good taste. For the earlier stages I'm just trying to get down the basics, and so anyone who knows the basics will do. For this, I'm trying to absorb good taste, and (some of) my friends are excelent programers.) Again, I'll rehearse / reify my new abstractions.

Then I'll repeat with a new project.



# Appendixes

## Books on learning

Books and resources that were at least somewhat helpful 


* Your Memory: How It Works and How to Improve It by Kenneth L. Higbee
* The Art of Learning An Inner Journey to Optimal Performance by Josh Waitzkin
* How We Learn: The Surprising Truth About When, Where, and Why It Happens by Benedict Carey
* The First 20 Hours: How to Learn Anything . . . Fast! by Josh Kaufman
* Tim Ferris's podcast on meta learning (#191)


Books and resources that were not worth reading

* Peak: Secrets from the New Science of Expertise by by Anders Ericsson and Robert Pool
* The Only Skill that Matters: The Proven Methodology to Read Faster, Remember More, and Become a SuperLearner by Jonathan A. Levi
* A Mind for Numbers: How to Excel at Math and Science (Even If You Flunked Algebra) by Barbara Oakley PhD




Not yet read

* Ultralearning
* Pragmatic Thinking and Learning
* The Five Pillars of Learning Mastery
* Talent is Overrated
* The Practicing Mind


# Scratch space and collected notes


**An outline of core skills**

- Learning
    - Embracing embarrassment
    - Not rushing
    - How to be engaged
    - Chunking to size 
        - (is this the same core idea as deliberate practice?)
    - Active learning / rephrasing / restatement / making guesses
    - Deliberate practice and training regime design
    - Tutoring
    - Mnemonic principles
    - Spaced Repetition



##### The 10 laws of shaping from Don't shoot the dog:
    - 1. Raise criteria in increments small enough that the subject always has a realistic chance for reinforcement.
    2. Train one aspect of any particular behavior at a time; don't try to shape for two criteria simultaneously.
    - 3. During shaping, put the current level of response onto a variable schedule of reinforcement before adding or raising the criteria.
    - 4. When introducing a new criterion, or aspect of the behavioral skill, temporarily relax the old ones.
    - 5. Stay ahead of your subject: Plan your shaping program completely so that if the subject makes sudden progress, you are aware of what to reinforce next.
    - 6. Don't change trainers in midstream; you can have several trainers per trainee, but stick to one shaper per behavior.
    - 7. If one shaping procedure is not eliciting progress, find another; there are as many ways to get behavior as there are trainers to think them up.
    - 8. Don't interrupt a training session gratuitously; that constitutes a punishment.
    - 9. If behavior deteriorates, "go back to kindergarten"; quickly review the whole shaping process with a series of easily earned reinforcers.
    - 10. End each session on a high note, if possible, but in any case quit while you're ahead.

